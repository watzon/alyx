version: 1

# Storage buckets define named storage containers with policies
# Buckets reference backends configured in alyx.yaml
buckets:
  # Example: Avatar storage with size and type restrictions
  avatars:
    backend: local # References alyx.yaml storage.backends.local
    max_file_size: 5242880 # 5MB in bytes
    allowed_types:
      - image/jpeg
      - image/png
      - image/webp
      - image/gif
    # Optional: Access control rules (CEL expressions)
    # rules:
    #   create: "auth.id != null"
    #   read: "true"
    #   delete: "auth.id == file.uploader_id || auth.role == 'admin'"

  # Example: Document storage with multiple file types
  documents:
    backend: local
    max_file_size: 10485760 # 10MB
    allowed_types:
      - application/pdf
      - application/msword
      - application/vnd.openxmlformats-officedocument.wordprocessingml.document
      - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    # Optional: Enable compression for text-based files
    # compression: true

    # Optional: Total bucket size limit
    # max_total_size: 1073741824  # 1GB

collections:
  users:
    fields:
      id:
        type: uuid
        primary: true
        default: auto
      email:
        type: string
        unique: true
        index: true
        validate:
          format: email
      name:
        type: string
        maxLength: 100
        nullable: true
      avatar:
        type: file
        nullable: true
        file:
          bucket: avatars
          max_size: 5242880
          allowed_types:
            - image/jpeg
            - image/png
            - image/webp
          on_delete: cascade
      role:
        type: string
        default: "user"
        validate:
          enum: [user, moderator, admin]
      created_at:
        type: timestamp
        default: now
      updated_at:
        type: timestamp
        default: now
        onUpdate: now

    rules:
      create: "true"
      read: "auth.id == doc.id || auth.role == 'admin'"
      update: "auth.id == doc.id"
      delete: "auth.role == 'admin'"

  posts:
    fields:
      id:
        type: uuid
        primary: true
        default: auto
      title:
        type: string
        minLength: 1
        maxLength: 200
      slug:
        type: string
        unique: true
        index: true
      featured_image:
        type: file
        nullable: true
        file:
          bucket: documents
          on_delete: set_null
      content:
        type: text
      excerpt:
        type: string
        maxLength: 500
        nullable: true
      author_id:
        type: uuid
        references: users.id
        onDelete: cascade
        index: true
      published:
        type: bool
        default: false
      published_at:
        type: timestamp
        nullable: true
      tags:
        type: json
        nullable: true
      view_count:
        type: int
        default: 0
      created_at:
        type: timestamp
        default: now
      updated_at:
        type: timestamp
        default: now
        onUpdate: now

    indexes:
      - name: idx_posts_published_date
        fields: [published, published_at]
        order: desc
      - name: idx_posts_author_date
        fields: [author_id, created_at]
        order: desc

    rules:
      create: "auth.id != null"
      read: "doc.published == true || auth.id == doc.author_id || auth.role == 'admin'"
      update: "auth.id == doc.author_id || auth.role == 'admin'"
      delete: "auth.id == doc.author_id || auth.role == 'admin'"

  comments:
    fields:
      id:
        type: uuid
        primary: true
        default: auto
      post_id:
        type: uuid
        references: posts.id
        onDelete: cascade
        index: true
      author_id:
        type: uuid
        references: users.id
        onDelete: cascade
      content:
        type: text
        maxLength: 5000
      created_at:
        type: timestamp
        default: now

    rules:
      create: "auth.id != null"
      read: "true"
      update: "auth.id == doc.author_id"
      delete: "auth.id == doc.author_id || auth.role in ['moderator', 'admin']"
