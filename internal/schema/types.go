package schema

import (
	"fmt"
	"strings"
)

type FieldType string

const (
	FieldTypeUUID      FieldType = "uuid"
	FieldTypeString    FieldType = "string"
	FieldTypeText      FieldType = "text"
	FieldTypeInt       FieldType = "int"
	FieldTypeFloat     FieldType = "float"
	FieldTypeBool      FieldType = "bool"
	FieldTypeTimestamp FieldType = "timestamp"
	FieldTypeJSON      FieldType = "json"
	FieldTypeBlob      FieldType = "blob"
)

func (t FieldType) IsValid() bool {
	switch t {
	case FieldTypeUUID, FieldTypeString, FieldTypeText, FieldTypeInt,
		FieldTypeFloat, FieldTypeBool, FieldTypeTimestamp, FieldTypeJSON, FieldTypeBlob:
		return true
	}
	return false
}

func (t FieldType) SQLiteType() string {
	switch t {
	case FieldTypeUUID, FieldTypeString, FieldTypeText, FieldTypeTimestamp, FieldTypeJSON:
		return "TEXT"
	case FieldTypeInt, FieldTypeBool:
		return "INTEGER"
	case FieldTypeFloat:
		return "REAL"
	case FieldTypeBlob:
		return "BLOB"
	default:
		return "TEXT"
	}
}

func (t FieldType) GoType(nullable bool) string {
	prefix := ""
	if nullable {
		prefix = "*"
	}
	switch t {
	case FieldTypeUUID, FieldTypeString, FieldTypeText:
		return prefix + "string"
	case FieldTypeInt:
		return prefix + "int64"
	case FieldTypeFloat:
		return prefix + "float64"
	case FieldTypeBool:
		return prefix + "bool"
	case FieldTypeTimestamp:
		return prefix + "time.Time"
	case FieldTypeJSON:
		return "any"
	case FieldTypeBlob:
		return "[]byte"
	default:
		return prefix + "string"
	}
}

func (t FieldType) TypeScriptType(nullable bool) string {
	var base string
	switch t {
	case FieldTypeUUID, FieldTypeString, FieldTypeText:
		base = "string"
	case FieldTypeInt, FieldTypeFloat:
		base = "number"
	case FieldTypeBool:
		base = "boolean"
	case FieldTypeTimestamp:
		base = "Date"
	case FieldTypeJSON:
		base = "unknown"
	case FieldTypeBlob:
		base = "Uint8Array"
	default:
		base = "string"
	}
	if nullable {
		return base + " | null"
	}
	return base
}

func (t FieldType) PythonType(nullable bool) string {
	var base string
	switch t {
	case FieldTypeUUID, FieldTypeString, FieldTypeText:
		base = "str"
	case FieldTypeInt:
		base = "int"
	case FieldTypeFloat:
		base = "float"
	case FieldTypeBool:
		base = "bool"
	case FieldTypeTimestamp:
		base = "datetime"
	case FieldTypeJSON:
		base = "Any"
	case FieldTypeBlob:
		base = "bytes"
	default:
		base = "str"
	}
	if nullable {
		return "Optional[" + base + "]"
	}
	return base
}

type OnDeleteAction string

const (
	OnDeleteRestrict OnDeleteAction = "restrict"
	OnDeleteCascade  OnDeleteAction = "cascade"
	OnDeleteSetNull  OnDeleteAction = "set null"
)

func (a OnDeleteAction) IsValid() bool {
	switch a {
	case OnDeleteRestrict, OnDeleteCascade, OnDeleteSetNull, "":
		return true
	}
	return false
}

func (a OnDeleteAction) SQL() string {
	switch a {
	case OnDeleteCascade:
		return "CASCADE"
	case OnDeleteSetNull:
		return "SET NULL"
	default:
		return "RESTRICT"
	}
}

type DefaultValue string

const (
	DefaultAuto DefaultValue = "auto"
	DefaultNow  DefaultValue = "now"
)

type Schema struct {
	Version     int                    `yaml:"version"`
	Collections map[string]*Collection `yaml:"collections"`
}

type Collection struct {
	Name    string            `yaml:"-"`
	Fields  map[string]*Field `yaml:"fields"`
	Indexes []*Index          `yaml:"indexes"`
	Rules   *Rules            `yaml:"rules"`

	fieldOrder []string
}

func (c *Collection) FieldOrder() []string {
	return c.fieldOrder
}

func (c *Collection) SetFieldOrder(order []string) {
	c.fieldOrder = order
}

func (c *Collection) OrderedFields() []*Field {
	fields := make([]*Field, 0, len(c.fieldOrder))
	for _, name := range c.fieldOrder {
		if f, ok := c.Fields[name]; ok {
			fields = append(fields, f)
		}
	}
	return fields
}

func (c *Collection) PrimaryKeyField() *Field {
	for _, f := range c.Fields {
		if f.Primary {
			return f
		}
	}
	return nil
}

type Field struct {
	Name       string           `yaml:"-"`
	Type       FieldType        `yaml:"type"`
	Primary    bool             `yaml:"primary"`
	Unique     bool             `yaml:"unique"`
	Nullable   bool             `yaml:"nullable"`
	Index      bool             `yaml:"index"`
	Default    string           `yaml:"default"`
	References string           `yaml:"references"`
	OnDelete   OnDeleteAction   `yaml:"onDelete"`
	OnUpdate   string           `yaml:"onUpdate"`
	Internal   bool             `yaml:"internal"`
	Validate   *FieldValidation `yaml:"validate"`

	MinLength *int `yaml:"minLength"`
	MaxLength *int `yaml:"maxLength"`
}

func (f *Field) HasDefault() bool {
	return f.Default != ""
}

func (f *Field) IsAutoGenerated() bool {
	return f.Default == string(DefaultAuto)
}

func (f *Field) IsTimestampNow() bool {
	return f.Default == string(DefaultNow)
}

func (f *Field) IsAutoUpdateTimestamp() bool {
	return f.OnUpdate == string(DefaultNow)
}

func (f *Field) ParseReference() (table, field string, ok bool) {
	if f.References == "" {
		return "", "", false
	}
	parts := strings.SplitN(f.References, ".", 2)
	if len(parts) != 2 {
		return "", "", false
	}
	return parts[0], parts[1], true
}

func (f *Field) SQLDefault() string {
	if f.Default == "" {
		return ""
	}
	switch f.Default {
	case string(DefaultAuto):
		if f.Type == FieldTypeUUID {
			return ""
		}
		return ""
	case string(DefaultNow):
		return "(datetime('now'))"
	default:
		switch f.Type {
		case FieldTypeString, FieldTypeText, FieldTypeUUID:
			return fmt.Sprintf("'%s'", strings.ReplaceAll(f.Default, "'", "''"))
		case FieldTypeBool:
			if f.Default == "true" {
				return "1"
			}
			return "0"
		default:
			return f.Default
		}
	}
}

type FieldValidation struct {
	MinLength *int     `yaml:"minLength"`
	MaxLength *int     `yaml:"maxLength"`
	Min       *float64 `yaml:"min"`
	Max       *float64 `yaml:"max"`
	Format    string   `yaml:"format"`
	Pattern   string   `yaml:"pattern"`
	Enum      []string `yaml:"enum"`
}

type Index struct {
	Name   string   `yaml:"name"`
	Fields []string `yaml:"fields"`
	Unique bool     `yaml:"unique"`
	Order  string   `yaml:"order"`
}

func (i *Index) SQL(tableName string) string {
	uniqueStr := ""
	if i.Unique {
		uniqueStr = "UNIQUE "
	}

	orderStr := ""
	if i.Order != "" {
		orderStr = " " + strings.ToUpper(i.Order)
	}

	fieldList := make([]string, len(i.Fields))
	for idx, f := range i.Fields {
		fieldList[idx] = f + orderStr
	}

	return fmt.Sprintf("CREATE %sINDEX IF NOT EXISTS %s ON %s (%s)",
		uniqueStr, i.Name, tableName, strings.Join(fieldList, ", "))
}

type Rules struct {
	Create string `yaml:"create"`
	Read   string `yaml:"read"`
	Update string `yaml:"update"`
	Delete string `yaml:"delete"`
}

func (r *Rules) HasRules() bool {
	return r != nil && (r.Create != "" || r.Read != "" || r.Update != "" || r.Delete != "")
}
