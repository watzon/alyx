package codegen

import (
	"fmt"
	"strings"

	"github.com/watzon/alyx/internal/schema"
)

// GoGenerator generates Go client code.
type GoGenerator struct {
	cfg *Config
}

// NewGoGenerator creates a new Go generator.
func NewGoGenerator(cfg *Config) *GoGenerator {
	return &GoGenerator{cfg: cfg}
}

// Language returns the target language.
func (g *GoGenerator) Language() Language {
	return LanguageGo
}

// Generate produces Go client code from a schema.
func (g *GoGenerator) Generate(s *schema.Schema) ([]GeneratedFile, error) {
	var files []GeneratedFile

	// Generate types file
	typesContent := g.generateTypes(s)
	files = append(files, GeneratedFile{
		Path:    "types.go",
		Content: typesContent,
	})

	// Generate client file
	clientContent := g.generateClient(s)
	files = append(files, GeneratedFile{
		Path:    "client.go",
		Content: clientContent,
	})

	return files, nil
}

func (g *GoGenerator) generateTypes(s *schema.Schema) string {
	var b strings.Builder

	b.WriteString("// Code generated by Alyx. DO NOT EDIT.\n\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", g.cfg.PackageName))

	// Check if we need time import
	needsTime := false
	for _, coll := range s.Collections {
		for _, field := range coll.Fields {
			if field.Type == schema.FieldTypeTimestamp {
				needsTime = true
				break
			}
		}
		if needsTime {
			break
		}
	}

	if needsTime {
		b.WriteString("import \"time\"\n\n")
	}

	// Generate struct for each collection
	for _, name := range sortedCollectionNames(s) {
		coll := s.Collections[name]
		g.generateCollectionStruct(&b, name, coll)
		b.WriteString("\n")
	}

	// Generate create/update input types
	for _, name := range sortedCollectionNames(s) {
		coll := s.Collections[name]
		g.generateInputStructs(&b, name, coll)
		b.WriteString("\n")
	}

	return b.String()
}

func (g *GoGenerator) generateCollectionStruct(b *strings.Builder, name string, coll *schema.Collection) {
	typeName := toPascalCase(name)

	b.WriteString(fmt.Sprintf("// %s represents a document in the %s collection.\n", typeName, name))
	b.WriteString(fmt.Sprintf("type %s struct {\n", typeName))

	for _, field := range coll.OrderedFields() {
		if field.Internal {
			continue
		}

		goType := field.Type.GoType(field.Nullable)
		fieldName := toPascalCase(field.Name)
		jsonTag := field.Name

		if field.Nullable {
			jsonTag += ",omitempty"
		}

		b.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag))
	}

	// Add expanded relation fields
	for _, field := range coll.OrderedFields() {
		if table, _, ok := field.ParseReference(); ok {
			refType := toPascalCase(table)
			fieldName := toPascalCase(field.Name) + "Expanded"
			b.WriteString(fmt.Sprintf("\t%s *%s `json:\"%s_expanded,omitempty\"`\n", fieldName, refType, field.Name))
		}
	}

	b.WriteString("}\n")
}

func (g *GoGenerator) generateInputStructs(b *strings.Builder, name string, coll *schema.Collection) {
	typeName := toPascalCase(name)

	// Create input type
	b.WriteString(fmt.Sprintf("// %sCreateInput is the input for creating a %s.\n", typeName, name))
	b.WriteString(fmt.Sprintf("type %sCreateInput struct {\n", typeName))

	for _, field := range coll.OrderedFields() {
		if field.Internal {
			continue
		}
		if field.Primary && field.IsAutoGenerated() {
			continue
		}
		if field.IsTimestampNow() || field.IsAutoUpdateTimestamp() {
			continue
		}

		// For optional fields, use pointers
		goType := field.Type.GoType(false)
		if field.Nullable || field.HasDefault() {
			goType = "*" + goType
		}

		fieldName := toPascalCase(field.Name)
		jsonTag := field.Name
		if field.Nullable || field.HasDefault() {
			jsonTag += ",omitempty"
		}

		b.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag))
	}

	b.WriteString("}\n\n")

	// Update input type (all fields as pointers for partial updates)
	b.WriteString(fmt.Sprintf("// %sUpdateInput is the input for updating a %s.\n", typeName, name))
	b.WriteString(fmt.Sprintf("type %sUpdateInput struct {\n", typeName))

	for _, field := range coll.OrderedFields() {
		if field.Internal {
			continue
		}
		if field.Primary {
			continue
		}
		if field.IsAutoUpdateTimestamp() {
			continue
		}

		goType := "*" + field.Type.GoType(false)
		fieldName := toPascalCase(field.Name)
		jsonTag := field.Name + ",omitempty"

		b.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag))
	}

	b.WriteString("}\n")
}

func (g *GoGenerator) generateClient(s *schema.Schema) string {
	var b strings.Builder

	b.WriteString("// Code generated by Alyx. DO NOT EDIT.\n\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", g.cfg.PackageName))

	b.WriteString(`import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// Client is the Alyx API client.
type Client struct {
	baseURL    string
	httpClient *http.Client
	token      string
`)

	// Add collection fields
	for _, name := range sortedCollectionNames(s) {
		fieldName := toPascalCase(name)
		b.WriteString(fmt.Sprintf("\t%s *%sCollection\n", fieldName, fieldName))
	}

	b.WriteString(`}

// ClientOption configures the client.
type ClientOption func(*Client)

// WithHTTPClient sets a custom HTTP client.
func WithHTTPClient(c *http.Client) ClientOption {
	return func(client *Client) {
		client.httpClient = c
	}
}

// WithToken sets the auth token.
func WithToken(token string) ClientOption {
	return func(client *Client) {
		client.token = token
	}
}

// NewClient creates a new Alyx client.
func NewClient(baseURL string, opts ...ClientOption) *Client {
	c := &Client{
		baseURL:    strings.TrimRight(baseURL, "/"),
		httpClient: http.DefaultClient,
	}

	for _, opt := range opts {
		opt(c)
	}

`)

	// Initialize collection fields
	for _, name := range sortedCollectionNames(s) {
		fieldName := toPascalCase(name)
		b.WriteString(fmt.Sprintf("\tc.%s = &%sCollection{client: c, name: \"%s\"}\n", fieldName, fieldName, name))
	}

	b.WriteString(`
	return c
}

// SetToken sets the authentication token.
func (c *Client) SetToken(token string) {
	c.token = token
}

// request makes an HTTP request to the API.
func (c *Client) request(ctx context.Context, method, path string, body, result any) error {
	var bodyReader io.Reader
	if body != nil {
		data, err := json.Marshal(body)
		if err != nil {
			return fmt.Errorf("marshaling request body: %w", err)
		}
		bodyReader = bytes.NewReader(data)
	}

	req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, bodyReader)
	if err != nil {
		return fmt.Errorf("creating request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	if c.token != "" {
		req.Header.Set("Authorization", "Bearer "+c.token)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		var errResp struct {
			Message string ` + "`json:\"message\"`" + `
			Code    string ` + "`json:\"code\"`" + `
		}
		if err := json.NewDecoder(resp.Body).Decode(&errResp); err != nil {
			return fmt.Errorf("HTTP %d", resp.StatusCode)
		}
		return fmt.Errorf("%s: %s", errResp.Code, errResp.Message)
	}

	if result != nil && resp.StatusCode != http.StatusNoContent {
		if err := json.NewDecoder(resp.Body).Decode(result); err != nil {
			return fmt.Errorf("decoding response: %w", err)
		}
	}

	return nil
}

// PaginatedResponse holds a paginated list of items.
type PaginatedResponse[T any] struct {
	Items   []T ` + "`json:\"items\"`" + `
	Total   int ` + "`json:\"total\"`" + `
	Page    int ` + "`json:\"page\"`" + `
	PerPage int ` + "`json:\"per_page\"`" + `
}

// QueryOptions specifies options for list queries.
type QueryOptions struct {
	Filters map[string]any
	Sort    []string
	Limit   int
	Offset  int
	Expand  []string
}

// buildQueryString converts QueryOptions to a URL query string.
func buildQueryString(opts *QueryOptions) string {
	if opts == nil {
		return ""
	}

	params := url.Values{}

	for key, value := range opts.Filters {
		params.Add("filter", fmt.Sprintf("%s:eq:%v", key, value))
	}

	for _, s := range opts.Sort {
		params.Add("sort", s)
	}

	if opts.Limit > 0 {
		params.Set("limit", fmt.Sprintf("%d", opts.Limit))
	}

	if opts.Offset > 0 {
		params.Set("offset", fmt.Sprintf("%d", opts.Offset))
	}

	if len(opts.Expand) > 0 {
		params.Set("expand", strings.Join(opts.Expand, ","))
	}

	if len(params) == 0 {
		return ""
	}

	return "?" + params.Encode()
}

`)

	// Generate collection types
	for _, name := range sortedCollectionNames(s) {
		typeName := toPascalCase(name)
		g.generateCollectionMethods(&b, name, typeName)
	}

	// Auth methods
	b.WriteString(`// AuthResponse is the response from auth endpoints.
type AuthResponse struct {
	AccessToken  string ` + "`json:\"access_token\"`" + `
	RefreshToken string ` + "`json:\"refresh_token\"`" + `
	User         struct {
		ID       string         ` + "`json:\"id\"`" + `
		Email    string         ` + "`json:\"email\"`" + `
		Role     string         ` + "`json:\"role\"`" + `
		Verified bool           ` + "`json:\"verified\"`" + `
		Metadata map[string]any ` + "`json:\"metadata,omitempty\"`" + `
	} ` + "`json:\"user\"`" + `
}

// LoginCredentials for authentication.
type LoginCredentials struct {
	Email    string ` + "`json:\"email\"`" + `
	Password string ` + "`json:\"password\"`" + `
}

// RegisterData for user registration.
type RegisterData struct {
	Email    string         ` + "`json:\"email\"`" + `
	Password string         ` + "`json:\"password\"`" + `
	Name     string         ` + "`json:\"name,omitempty\"`" + `
	Metadata map[string]any ` + "`json:\"metadata,omitempty\"`" + `
}

// Login authenticates with email and password.
func (c *Client) Login(ctx context.Context, creds LoginCredentials) (*AuthResponse, error) {
	var resp AuthResponse
	if err := c.request(ctx, http.MethodPost, "/api/auth/login", creds, &resp); err != nil {
		return nil, err
	}
	c.token = resp.AccessToken
	return &resp, nil
}

// Register creates a new user account.
func (c *Client) Register(ctx context.Context, data RegisterData) (*AuthResponse, error) {
	var resp AuthResponse
	if err := c.request(ctx, http.MethodPost, "/api/auth/register", data, &resp); err != nil {
		return nil, err
	}
	c.token = resp.AccessToken
	return &resp, nil
}

// Logout invalidates the current session.
func (c *Client) Logout(ctx context.Context) error {
	if err := c.request(ctx, http.MethodPost, "/api/auth/logout", nil, nil); err != nil {
		return err
	}
	c.token = ""
	return nil
}

// RefreshToken refreshes the access token.
func (c *Client) RefreshToken(ctx context.Context, refreshToken string) (*AuthResponse, error) {
	var resp AuthResponse
	body := map[string]string{"refresh_token": refreshToken}
	if err := c.request(ctx, http.MethodPost, "/api/auth/refresh", body, &resp); err != nil {
		return nil, err
	}
	c.token = resp.AccessToken
	return &resp, nil
}
`)

	return b.String()
}

func (g *GoGenerator) generateCollectionMethods(b *strings.Builder, name, typeName string) {
	b.WriteString(fmt.Sprintf(`// %sCollection provides operations for the %s collection.
type %sCollection struct {
	client *Client
	name   string
}

// List retrieves a paginated list of %s documents.
func (c *%sCollection) List(ctx context.Context, opts *QueryOptions) (*PaginatedResponse[%s], error) {
	var resp PaginatedResponse[%s]
	path := "/api/collections/" + c.name + buildQueryString(opts)
	if err := c.client.request(ctx, http.MethodGet, path, nil, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Get retrieves a single %s by ID.
func (c *%sCollection) Get(ctx context.Context, id string, expand ...string) (*%s, error) {
	var resp %s
	path := "/api/collections/" + c.name + "/" + id
	if len(expand) > 0 {
		path += "?expand=" + strings.Join(expand, ",")
	}
	if err := c.client.request(ctx, http.MethodGet, path, nil, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Create creates a new %s document.
func (c *%sCollection) Create(ctx context.Context, input %sCreateInput) (*%s, error) {
	var resp %s
	path := "/api/collections/" + c.name
	if err := c.client.request(ctx, http.MethodPost, path, input, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Update updates an existing %s document.
func (c *%sCollection) Update(ctx context.Context, id string, input %sUpdateInput) (*%s, error) {
	var resp %s
	path := "/api/collections/" + c.name + "/" + id
	if err := c.client.request(ctx, http.MethodPatch, path, input, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Delete removes a %s document.
func (c *%sCollection) Delete(ctx context.Context, id string) error {
	path := "/api/collections/" + c.name + "/" + id
	return c.client.request(ctx, http.MethodDelete, path, nil, nil)
}

`, typeName, name, typeName, name, typeName, typeName, typeName, name, typeName, typeName, typeName, name, typeName, typeName, typeName, typeName, name, typeName, typeName, typeName, typeName, name, typeName))
}
