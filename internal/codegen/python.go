package codegen

import (
	"fmt"
	"strings"

	"github.com/watzon/alyx/internal/schema"
)

// PythonGenerator generates Python client code.
type PythonGenerator struct {
	cfg *Config
}

// NewPythonGenerator creates a new Python generator.
func NewPythonGenerator(cfg *Config) *PythonGenerator {
	return &PythonGenerator{cfg: cfg}
}

// Language returns the target language.
func (g *PythonGenerator) Language() Language {
	return LanguagePython
}

// Generate produces Python client code from a schema.
func (g *PythonGenerator) Generate(s *schema.Schema) ([]GeneratedFile, error) {
	var files []GeneratedFile

	// Generate models file
	modelsContent := g.generateModels(s)
	files = append(files, GeneratedFile{
		Path:    "models.py",
		Content: modelsContent,
	})

	// Generate client file
	clientContent := g.generateClient(s)
	files = append(files, GeneratedFile{
		Path:    "client.py",
		Content: clientContent,
	})

	// Generate __init__.py
	initContent := g.generateInit(s)
	files = append(files, GeneratedFile{
		Path:    "__init__.py",
		Content: initContent,
	})

	return files, nil
}

func (g *PythonGenerator) generateModels(s *schema.Schema) string {
	var b strings.Builder

	b.WriteString(`# Generated by Alyx - DO NOT EDIT

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Optional, List, Dict

`)

	// Generate dataclass for each collection
	for _, name := range sortedCollectionNames(s) {
		coll := s.Collections[name]
		g.generateModelClass(&b, name, coll)
		b.WriteString("\n\n")
	}

	// Generate input types
	for _, name := range sortedCollectionNames(s) {
		coll := s.Collections[name]
		g.generateInputClasses(&b, name, coll)
		b.WriteString("\n")
	}

	return b.String()
}

func (g *PythonGenerator) generateModelClass(b *strings.Builder, name string, coll *schema.Collection) {
	className := toPascalCase(name)

	b.WriteString(fmt.Sprintf("@dataclass\nclass %s:\n", className))
	b.WriteString(fmt.Sprintf("    \"\"\"%s document.\"\"\"\n\n", className))

	// Required fields first, then optional
	var required, optional []string

	for _, field := range coll.OrderedFields() {
		if field.Internal {
			continue
		}

		pyType := field.Type.PythonType(field.Nullable)
		fieldName := toSnakeCase(field.Name)

		if field.Nullable {
			optional = append(optional, fmt.Sprintf("    %s: %s = None", fieldName, pyType))
		} else {
			required = append(required, fmt.Sprintf("    %s: %s", fieldName, pyType))
		}
	}

	// Add expanded relation fields (always optional)
	for _, field := range coll.OrderedFields() {
		if table, _, ok := field.ParseReference(); ok {
			refType := toPascalCase(table)
			fieldName := toSnakeCase(field.Name) + "_expanded"
			optional = append(optional, fmt.Sprintf("    %s: Optional['%s'] = None", fieldName, refType))
		}
	}

	for _, line := range required {
		b.WriteString(line + "\n")
	}
	for _, line := range optional {
		b.WriteString(line + "\n")
	}

	if len(required) == 0 && len(optional) == 0 {
		b.WriteString("    pass\n")
	}
}

func (g *PythonGenerator) generateInputClasses(b *strings.Builder, name string, coll *schema.Collection) {
	className := toPascalCase(name)
	g.generateCreateInput(b, className, coll)
	b.WriteString("\n\n")
	g.generateUpdateInput(b, className, coll)
}

func (g *PythonGenerator) generateCreateInput(b *strings.Builder, className string, coll *schema.Collection) {
	b.WriteString(fmt.Sprintf("@dataclass\nclass %sCreateInput:\n", className))
	b.WriteString(fmt.Sprintf("    \"\"\"Input for creating a %s.\"\"\"\n\n", className))

	var required, optional []string

	for _, field := range coll.OrderedFields() {
		if g.skipForCreate(field) {
			continue
		}

		pyType := field.Type.PythonType(false)
		fieldName := toSnakeCase(field.Name)

		if field.Nullable || field.HasDefault() {
			optional = append(optional, fmt.Sprintf("    %s: Optional[%s] = None", fieldName, pyType))
		} else {
			required = append(required, fmt.Sprintf("    %s: %s", fieldName, pyType))
		}
	}

	g.writeFieldLines(b, required, optional)
}

func (g *PythonGenerator) skipForCreate(field *schema.Field) bool {
	if field.Internal {
		return true
	}
	if field.Primary && field.IsAutoGenerated() {
		return true
	}
	if field.IsTimestampNow() || field.IsAutoUpdateTimestamp() {
		return true
	}
	return false
}

func (g *PythonGenerator) generateUpdateInput(b *strings.Builder, className string, coll *schema.Collection) {
	b.WriteString(fmt.Sprintf("@dataclass\nclass %sUpdateInput:\n", className))
	b.WriteString(fmt.Sprintf("    \"\"\"Input for updating a %s.\"\"\"\n\n", className))

	hasFields := false
	for _, field := range coll.OrderedFields() {
		if g.skipForUpdate(field) {
			continue
		}

		pyType := field.Type.PythonType(false)
		fieldName := toSnakeCase(field.Name)
		b.WriteString(fmt.Sprintf("    %s: Optional[%s] = None\n", fieldName, pyType))
		hasFields = true
	}

	if !hasFields {
		b.WriteString("    pass\n")
	}
}

func (g *PythonGenerator) skipForUpdate(field *schema.Field) bool {
	if field.Internal {
		return true
	}
	if field.Primary {
		return true
	}
	if field.IsAutoUpdateTimestamp() {
		return true
	}
	return false
}

func (g *PythonGenerator) writeFieldLines(b *strings.Builder, required, optional []string) {
	for _, line := range required {
		b.WriteString(line + "\n")
	}
	for _, line := range optional {
		b.WriteString(line + "\n")
	}

	if len(required) == 0 && len(optional) == 0 {
		b.WriteString("    pass\n")
	}
}

func (g *PythonGenerator) generateClient(s *schema.Schema) string {
	var b strings.Builder

	b.WriteString(`# Generated by Alyx - DO NOT EDIT

from dataclasses import asdict
from datetime import datetime
from typing import Any, Dict, Generic, List, Optional, TypeVar, Callable
from urllib.parse import urlencode
import json

try:
    import httpx
    HAS_HTTPX = True
except ImportError:
    import urllib.request
    import urllib.error
    HAS_HTTPX = False

from .models import (
`)

	// Import models
	for _, name := range sortedCollectionNames(s) {
		className := toPascalCase(name)
		b.WriteString(fmt.Sprintf("    %s,\n", className))
		b.WriteString(fmt.Sprintf("    %sCreateInput,\n", className))
		b.WriteString(fmt.Sprintf("    %sUpdateInput,\n", className))
	}

	b.WriteString(`)

T = TypeVar('T')
TCreate = TypeVar('TCreate')
TUpdate = TypeVar('TUpdate')


class PaginatedResponse(Generic[T]):
    """Paginated response from the API."""

    def __init__(self, items: List[T], total: int, page: int, per_page: int):
        self.items = items
        self.total = total
        self.page = page
        self.per_page = per_page


class Collection(Generic[T, TCreate, TUpdate]):
    """Collection provides CRUD operations for a specific collection."""

    def __init__(self, client: 'AlyxClient', name: str, model_class: type):
        self._client = client
        self._name = name
        self._model_class = model_class

    def list(
        self,
        filters: Optional[Dict[str, Any]] = None,
        sort: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        expand: Optional[List[str]] = None,
    ) -> PaginatedResponse[T]:
        """List documents with optional filtering."""
        params = self._build_query_params(filters, sort, limit, offset, expand)
        path = f"/api/collections/{self._name}"
        if params:
            path += "?" + urlencode(params, doseq=True)

        data = self._client._request("GET", path)
        items = [self._model_class(**item) for item in data.get("items", [])]
        return PaginatedResponse(
            items=items,
            total=data.get("total", 0),
            page=data.get("page", 1),
            per_page=data.get("per_page", 20),
        )

    def get(self, id: str, expand: Optional[List[str]] = None) -> T:
        """Get a single document by ID."""
        path = f"/api/collections/{self._name}/{id}"
        if expand:
            path += "?expand=" + ",".join(expand)

        data = self._client._request("GET", path)
        return self._model_class(**data)

    def create(self, input: TCreate) -> T:
        """Create a new document."""
        path = f"/api/collections/{self._name}"
        body = asdict(input) if hasattr(input, '__dataclass_fields__') else input
        # Remove None values
        body = {k: v for k, v in body.items() if v is not None}

        data = self._client._request("POST", path, body=body)
        return self._model_class(**data)

    def update(self, id: str, input: TUpdate) -> T:
        """Update an existing document."""
        path = f"/api/collections/{self._name}/{id}"
        body = asdict(input) if hasattr(input, '__dataclass_fields__') else input
        # Remove None values
        body = {k: v for k, v in body.items() if v is not None}

        data = self._client._request("PATCH", path, body=body)
        return self._model_class(**data)

    def delete(self, id: str) -> None:
        """Delete a document."""
        path = f"/api/collections/{self._name}/{id}"
        self._client._request("DELETE", path)

    def _build_query_params(
        self,
        filters: Optional[Dict[str, Any]],
        sort: Optional[List[str]],
        limit: Optional[int],
        offset: Optional[int],
        expand: Optional[List[str]],
    ) -> List[tuple]:
        params = []

        if filters:
            for key, value in filters.items():
                if isinstance(value, dict):
                    for op, v in value.items():
                        params.append(("filter", f"{key}:{op}:{v}"))
                else:
                    params.append(("filter", f"{key}:eq:{value}"))

        if sort:
            for s in sort:
                params.append(("sort", s))

        if limit is not None:
            params.append(("limit", str(limit)))

        if offset is not None:
            params.append(("offset", str(offset)))

        if expand:
            params.append(("expand", ",".join(expand)))

        return params


class AuthResponse:
    """Response from authentication endpoints."""

    def __init__(
        self,
        access_token: str,
        refresh_token: str,
        user: Dict[str, Any],
    ):
        self.access_token = access_token
        self.refresh_token = refresh_token
        self.user = user


class AlyxClient:
    """Alyx API client."""

    def __init__(self, url: str, token: Optional[str] = None):
        self._url = url.rstrip("/")
        self._token = token
        self._httpx_client = None

        if HAS_HTTPX:
            self._httpx_client = httpx.Client(timeout=30.0)

`)

	// Add collection properties
	for _, name := range sortedCollectionNames(s) {
		className := toPascalCase(name)
		propName := toSnakeCase(name)
		b.WriteString(fmt.Sprintf("        self.%s = Collection[%s, %sCreateInput, %sUpdateInput](\n",
			propName, className, className, className))
		b.WriteString(fmt.Sprintf("            self, \"%s\", %s\n", name, className))
		b.WriteString("        )\n")
	}

	b.WriteString(`
    def set_token(self, token: Optional[str]) -> None:
        """Set the authentication token."""
        self._token = token

    def _request(
        self,
        method: str,
        path: str,
        body: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Make an HTTP request to the API."""
        url = self._url + path
        headers = {"Content-Type": "application/json"}

        if self._token:
            headers["Authorization"] = f"Bearer {self._token}"

        if HAS_HTTPX:
            return self._request_httpx(method, url, headers, body)
        return self._request_urllib(method, url, headers, body)

    def _request_httpx(
        self,
        method: str,
        url: str,
        headers: Dict[str, str],
        body: Optional[Dict[str, Any]],
    ) -> Any:
        """Make request using httpx."""
        response = self._httpx_client.request(
            method,
            url,
            headers=headers,
            json=body,
        )

        if response.status_code >= 400:
            try:
                error = response.json()
                raise Exception(f"{error.get('code', 'ERROR')}: {error.get('message', 'Unknown error')}")
            except json.JSONDecodeError:
                raise Exception(f"HTTP {response.status_code}")

        if response.status_code == 204:
            return None

        return response.json()

    def _request_urllib(
        self,
        method: str,
        url: str,
        headers: Dict[str, str],
        body: Optional[Dict[str, Any]],
    ) -> Any:
        """Make request using urllib (fallback)."""
        data = json.dumps(body).encode() if body else None
        req = urllib.request.Request(url, data=data, headers=headers, method=method)

        try:
            with urllib.request.urlopen(req, timeout=30) as response:
                if response.status == 204:
                    return None
                return json.loads(response.read())
        except urllib.error.HTTPError as e:
            try:
                error = json.loads(e.read())
                raise Exception(f"{error.get('code', 'ERROR')}: {error.get('message', 'Unknown error')}")
            except json.JSONDecodeError:
                raise Exception(f"HTTP {e.code}")

    # Auth methods

    def login(self, email: str, password: str) -> AuthResponse:
        """Login with email and password."""
        data = self._request("POST", "/api/auth/login", {"email": email, "password": password})
        self._token = data["access_token"]
        return AuthResponse(**data)

    def register(
        self,
        email: str,
        password: str,
        name: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> AuthResponse:
        """Register a new user."""
        body = {"email": email, "password": password}
        if name:
            body["name"] = name
        if metadata:
            body["metadata"] = metadata

        data = self._request("POST", "/api/auth/register", body)
        self._token = data["access_token"]
        return AuthResponse(**data)

    def logout(self) -> None:
        """Logout the current user."""
        self._request("POST", "/api/auth/logout")
        self._token = None

    def refresh_token(self, refresh_token: str) -> AuthResponse:
        """Refresh the access token."""
        data = self._request("POST", "/api/auth/refresh", {"refresh_token": refresh_token})
        self._token = data["access_token"]
        return AuthResponse(**data)

    def close(self) -> None:
        """Close the client and release resources."""
        if self._httpx_client:
            self._httpx_client.close()

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()


def create_client(url: str = "` + g.cfg.ServerURL + `", token: Optional[str] = None) -> AlyxClient:
    """Create a new Alyx client."""
    return AlyxClient(url, token)
`)

	return b.String()
}

func (g *PythonGenerator) generateInit(s *schema.Schema) string {
	var b strings.Builder

	b.WriteString(`# Generated by Alyx - DO NOT EDIT

from .models import (
`)

	for _, name := range sortedCollectionNames(s) {
		className := toPascalCase(name)
		b.WriteString(fmt.Sprintf("    %s,\n", className))
		b.WriteString(fmt.Sprintf("    %sCreateInput,\n", className))
		b.WriteString(fmt.Sprintf("    %sUpdateInput,\n", className))
	}

	b.WriteString(`)

from .client import (
    AlyxClient,
    AuthResponse,
    Collection,
    PaginatedResponse,
    create_client,
)

__all__ = [
    # Client
    "AlyxClient",
    "AuthResponse",
    "Collection",
    "PaginatedResponse",
    "create_client",
    # Models
`)

	for _, name := range sortedCollectionNames(s) {
		className := toPascalCase(name)
		b.WriteString(fmt.Sprintf("    \"%s\",\n", className))
		b.WriteString(fmt.Sprintf("    \"%sCreateInput\",\n", className))
		b.WriteString(fmt.Sprintf("    \"%sUpdateInput\",\n", className))
	}

	b.WriteString(`]
`)

	return b.String()
}
