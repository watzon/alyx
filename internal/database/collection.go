package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"

	"github.com/watzon/alyx/internal/schema"
)

var (
	ErrNotFound      = errors.New("document not found")
	ErrAlreadyExists = errors.New("document already exists")
)

type Collection struct {
	db          *DB
	schema      *schema.Collection
	name        string
	hookTrigger HookTrigger // Optional hook trigger for database events
}

// HookTrigger defines the interface for triggering database hooks.
type HookTrigger interface {
	OnInsert(ctx context.Context, collection string, document map[string]any) error
	OnUpdate(ctx context.Context, collection string, document, previousDocument map[string]any) error
	OnDelete(ctx context.Context, collection string, document map[string]any) error
}

func NewCollection(db *DB, s *schema.Collection) *Collection {
	return &Collection{
		db:          db,
		schema:      s,
		name:        s.Name,
		hookTrigger: nil,
	}
}

func (c *Collection) SetHookTrigger(trigger HookTrigger) {
	c.hookTrigger = trigger
}

func (c *Collection) Name() string {
	return c.name
}

func (c *Collection) Schema() *schema.Collection {
	return c.schema
}

type QueryOptions struct {
	Filters []*Filter
	Sorts   []*Sort
	Limit   int
	Offset  int
	Expand  []string
	Search  string // Full-text search across string/text fields
}

type QueryResult struct {
	Docs  []Row
	Total int64
}

func (c *Collection) Find(ctx context.Context, opts *QueryOptions) (*QueryResult, error) {
	if opts == nil {
		opts = &QueryOptions{}
	}

	q := NewQuery(c.name)

	for _, f := range opts.Filters {
		q.Filter(f.Field, f.Op, f.Value)
	}

	if opts.Search != "" {
		searchFields := c.getSearchableFields()
		if len(searchFields) > 0 {
			q.SearchOr(searchFields, opts.Search)
		}
	}

	for _, s := range opts.Sorts {
		q.Sort(s.Field, s.Order)
	}

	if opts.Limit > 0 {
		q.Limit(opts.Limit)
	}

	if opts.Offset > 0 {
		q.Offset(opts.Offset)
	}

	countSQL, countArgs := q.BuildCount()
	var total int64
	if err := c.db.QueryRowContext(ctx, countSQL, countArgs...).Scan(&total); err != nil {
		return nil, fmt.Errorf("counting documents: %w", err)
	}

	querySQL, queryArgs := q.Build()
	rows, err := c.db.QueryContext(ctx, querySQL, queryArgs...)
	if err != nil {
		return nil, fmt.Errorf("querying documents: %w", err)
	}
	defer rows.Close()

	docs, err := ScanRows(rows)
	if err != nil {
		return nil, err
	}

	for i, doc := range docs {
		docs[i] = c.processRow(doc)
	}

	return &QueryResult{Docs: docs, Total: total}, nil
}

func (c *Collection) FindOne(ctx context.Context, id string) (Row, error) {
	pk := c.schema.PrimaryKeyField()
	if pk == nil {
		return nil, errors.New("collection has no primary key")
	}

	q := NewQuery(c.name).Where(pk.Name, id).Limit(1)
	querySQL, args := q.Build()

	rows, err := c.db.QueryContext(ctx, querySQL, args...)
	if err != nil {
		return nil, fmt.Errorf("querying document: %w", err)
	}
	defer rows.Close()

	docs, err := ScanRows(rows)
	if err != nil {
		return nil, err
	}

	if len(docs) == 0 {
		return nil, ErrNotFound
	}

	return c.processRow(docs[0]), nil
}

func (c *Collection) Create(ctx context.Context, data Row) (Row, error) {
	pk := c.schema.PrimaryKeyField()
	if pk == nil {
		return nil, errors.New("collection has no primary key")
	}

	processedData := c.processInput(data, true)

	if pk.IsAutoGenerated() && shouldUseDefault(pk, processedData[pk.Name]) {
		switch pk.Type {
		case schema.FieldTypeID:
			processedData[pk.Name] = GenerateShortID()
		case schema.FieldTypeUUID:
			processedData[pk.Name] = uuid.New().String()
		default:
			processedData[pk.Name] = GenerateShortID()
		}
	}

	insert := NewInsert(c.name)
	for _, field := range c.schema.OrderedFields() {
		val, provided := processedData[field.Name]
		useDefault := shouldUseDefault(field, val)

		if provided && !useDefault {
			insert.Set(field.Name, val)
		} else if field.IsTimestampNow() {
			insert.Set(field.Name, Now())
		} else if field.HasStaticDefault() {
			insert.Set(field.Name, field.StaticDefault())
		} else if provided {
			insert.Set(field.Name, val)
		}
	}

	insertSQL, args := insert.Build()
	_, err := c.db.ExecContext(ctx, insertSQL, args...)
	if err != nil {
		if !errors.Is(ClassifyError(err), err) {
			return nil, ClassifyError(err)
		}
		return nil, fmt.Errorf("inserting document: %w", err)
	}

	doc, err := c.FindOne(ctx, fmt.Sprint(processedData[pk.Name]))
	if err != nil {
		return nil, err
	}

	if c.hookTrigger != nil {
		if hookErr := c.hookTrigger.OnInsert(ctx, c.name, doc); hookErr != nil {
			return nil, fmt.Errorf("hook trigger failed: %w", hookErr)
		}
	}

	return doc, nil
}

//nolint:gocyclo // CRUD operations require validation and hook handling
func (c *Collection) Update(ctx context.Context, id string, data Row) (Row, error) {
	pk := c.schema.PrimaryKeyField()
	if pk == nil {
		return nil, errors.New("collection has no primary key")
	}

	existing, err := c.FindOne(ctx, id)
	if err != nil {
		return nil, err
	}
	if existing == nil {
		return nil, ErrNotFound
	}

	processedData := c.processInput(data, false)

	update := NewUpdate(c.name).Where(pk.Name, id)

	for fieldName, value := range processedData {
		if fieldName == pk.Name {
			continue
		}
		field, ok := c.schema.Fields[fieldName]
		if !ok {
			continue
		}
		if field.IsAutoUpdateTimestamp() {
			continue
		}
		update.Set(fieldName, value)
	}

	for _, field := range c.schema.Fields {
		if field.IsAutoUpdateTimestamp() {
			update.Set(field.Name, Now())
		}
	}

	updateSQL, args := update.Build()
	result, err := c.db.ExecContext(ctx, updateSQL, args...)
	if err != nil {
		if !errors.Is(ClassifyError(err), err) {
			return nil, ClassifyError(err)
		}
		return nil, fmt.Errorf("updating document: %w", err)
	}

	if affected, affectedErr := result.RowsAffected(); affectedErr == nil && affected == 0 {
		return nil, ErrNotFound
	}

	doc, err := c.FindOne(ctx, id)
	if err != nil {
		return nil, err
	}

	if c.hookTrigger != nil {
		if hookErr := c.hookTrigger.OnUpdate(ctx, c.name, doc, existing); hookErr != nil {
			return nil, fmt.Errorf("hook trigger failed: %w", hookErr)
		}
	}

	return doc, nil
}

func (c *Collection) Delete(ctx context.Context, id string) error {
	pk := c.schema.PrimaryKeyField()
	if pk == nil {
		return errors.New("collection has no primary key")
	}

	existing, err := c.FindOne(ctx, id)
	if err != nil {
		return err
	}

	deleteSQL, args := NewDelete(c.name).Where(pk.Name, id).Build()
	result, err := c.db.ExecContext(ctx, deleteSQL, args...)
	if err != nil {
		return fmt.Errorf("deleting document: %w", err)
	}

	if affected, err := result.RowsAffected(); err == nil && affected == 0 {
		return ErrNotFound
	}

	if c.hookTrigger != nil {
		if hookErr := c.hookTrigger.OnDelete(ctx, c.name, existing); hookErr != nil {
			return fmt.Errorf("hook trigger failed: %w", hookErr)
		}
	}

	return nil
}

func (c *Collection) Count(ctx context.Context, filters []*Filter) (int64, error) {
	q := NewQuery(c.name)
	for _, f := range filters {
		q.Filter(f.Field, f.Op, f.Value)
	}

	countSQL, args := q.BuildCount()
	var count int64
	if err := c.db.QueryRowContext(ctx, countSQL, args...).Scan(&count); err != nil {
		return 0, fmt.Errorf("counting documents: %w", err)
	}

	return count, nil
}

func (c *Collection) Exists(ctx context.Context, id string) (bool, error) {
	pk := c.schema.PrimaryKeyField()
	if pk == nil {
		return false, errors.New("collection has no primary key")
	}

	q := NewQuery(c.name).Select("1").Where(pk.Name, id).Limit(1)
	querySQL, args := q.Build()

	var exists int
	err := c.db.QueryRowContext(ctx, querySQL, args...).Scan(&exists)
	if errors.Is(err, sql.ErrNoRows) {
		return false, nil
	}
	if err != nil {
		return false, err
	}

	return true, nil
}

func (c *Collection) processInput(data Row, isCreate bool) Row {
	result := make(Row)

	for fieldName, value := range data {
		field, ok := c.schema.Fields[fieldName]
		if !ok {
			continue
		}

		if field.Internal && !isCreate {
			continue
		}

		converted := c.convertValue(value, field)

		if field.Type == schema.FieldTypeRichText {
			if str, ok := converted.(string); ok && str != "" {
				converted = schema.SanitizeRichText(str, field.RichText)
			}
		}

		result[fieldName] = converted
	}

	return result
}

func (c *Collection) processRow(row Row) Row {
	for fieldName, value := range row {
		field, ok := c.schema.Fields[fieldName]
		if !ok {
			continue
		}

		if field.Internal {
			delete(row, fieldName)
			continue
		}

		switch field.Type {
		case schema.FieldTypeBool:
			if v, ok := value.(int64); ok {
				row[fieldName] = v != 0
			}
		case schema.FieldTypeJSON:
			if s, ok := value.(string); ok && s != "" {
				var parsed any
				if err := json.Unmarshal([]byte(s), &parsed); err == nil {
					row[fieldName] = parsed
				}
			}
		case schema.FieldTypeTimestamp:
			if s, ok := value.(string); ok && s != "" {
				if t, err := time.Parse(time.RFC3339, s); err == nil {
					row[fieldName] = t
				}
			}
		case schema.FieldTypeSelect:
			if s, ok := value.(string); ok && s != "" {
				var parsed any
				if err := json.Unmarshal([]byte(s), &parsed); err == nil {
					row[fieldName] = parsed
				} else {
					row[fieldName] = s
				}
			}
		case schema.FieldTypeID, schema.FieldTypeUUID, schema.FieldTypeString, schema.FieldTypeText, schema.FieldTypeRichText,
			schema.FieldTypeInt, schema.FieldTypeFloat, schema.FieldTypeBlob,
			schema.FieldTypeEmail, schema.FieldTypeURL, schema.FieldTypeDate, schema.FieldTypeRelation:
		}
	}

	return row
}

func (c *Collection) getSearchableFields() []string {
	var fields []string
	for _, f := range c.schema.OrderedFields() {
		switch f.Type {
		case schema.FieldTypeID, schema.FieldTypeString, schema.FieldTypeText, schema.FieldTypeUUID,
			schema.FieldTypeEmail, schema.FieldTypeURL:
			fields = append(fields, f.Name)
		case schema.FieldTypeRichText, schema.FieldTypeInt, schema.FieldTypeFloat,
			schema.FieldTypeBool, schema.FieldTypeTimestamp, schema.FieldTypeJSON,
			schema.FieldTypeBlob, schema.FieldTypeDate, schema.FieldTypeSelect,
			schema.FieldTypeRelation:
		}
	}
	return fields
}

func (c *Collection) convertValue(value any, field *schema.Field) any {
	if value == nil {
		return nil
	}

	switch field.Type {
	case schema.FieldTypeBool:
		switch v := value.(type) {
		case bool:
			if v {
				return 1
			}
			return 0
		case int, int64, float64:
			return v
		}
	case schema.FieldTypeJSON:
		switch v := value.(type) {
		case string:
			return v
		default:
			if b, err := json.Marshal(v); err == nil {
				return string(b)
			}
		}
	case schema.FieldTypeTimestamp:
		switch v := value.(type) {
		case time.Time:
			return v.UTC().Format(time.RFC3339)
		case string:
			return v
		}
	case schema.FieldTypeSelect:
		switch v := value.(type) {
		case string:
			return v
		case []string:
			if b, err := json.Marshal(v); err == nil {
				return string(b)
			}
		case []any:
			if b, err := json.Marshal(v); err == nil {
				return string(b)
			}
		}
	case schema.FieldTypeID, schema.FieldTypeUUID, schema.FieldTypeString, schema.FieldTypeText, schema.FieldTypeRichText,
		schema.FieldTypeInt, schema.FieldTypeFloat, schema.FieldTypeBlob,
		schema.FieldTypeEmail, schema.FieldTypeURL, schema.FieldTypeDate, schema.FieldTypeRelation:
	}

	return value
}

func isEmptyOrMissing(data Row, key string) bool {
	val, ok := data[key]
	if !ok || val == nil {
		return true
	}
	if s, ok := val.(string); ok && s == "" {
		return true
	}
	return false
}

func isEmptyValue(v any) bool {
	if v == nil {
		return true
	}
	if s, ok := v.(string); ok && s == "" {
		return true
	}
	return false
}

func shouldUseDefault(field *schema.Field, v any) bool {
	if isEmptyValue(v) {
		return true
	}
	s, ok := v.(string)
	if !ok {
		return false
	}
	if field.IsAutoGenerated() && s == "auto" {
		return true
	}
	if field.IsTimestampNow() && s == "now" {
		return true
	}
	return false
}
