package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"

	"github.com/watzon/alyx/internal/schema"
)

var (
	ErrNotFound      = errors.New("document not found")
	ErrAlreadyExists = errors.New("document already exists")
)

type Collection struct {
	db     *DB
	schema *schema.Collection
	name   string
}

func NewCollection(db *DB, s *schema.Collection) *Collection {
	return &Collection{
		db:     db,
		schema: s,
		name:   s.Name,
	}
}

func (c *Collection) Name() string {
	return c.name
}

func (c *Collection) Schema() *schema.Collection {
	return c.schema
}

type QueryOptions struct {
	Filters []*Filter
	Sorts   []*Sort
	Limit   int
	Offset  int
	Expand  []string
	Search  string // Full-text search across string/text fields
}

type QueryResult struct {
	Docs  []Row
	Total int64
}

func (c *Collection) Find(ctx context.Context, opts *QueryOptions) (*QueryResult, error) {
	if opts == nil {
		opts = &QueryOptions{}
	}

	q := NewQuery(c.name)

	for _, f := range opts.Filters {
		q.Filter(f.Field, f.Op, f.Value)
	}

	if opts.Search != "" {
		searchFields := c.getSearchableFields()
		if len(searchFields) > 0 {
			q.SearchOr(searchFields, opts.Search)
		}
	}

	for _, s := range opts.Sorts {
		q.Sort(s.Field, s.Order)
	}

	if opts.Limit > 0 {
		q.Limit(opts.Limit)
	}

	if opts.Offset > 0 {
		q.Offset(opts.Offset)
	}

	countSQL, countArgs := q.BuildCount()
	var total int64
	if err := c.db.QueryRowContext(ctx, countSQL, countArgs...).Scan(&total); err != nil {
		return nil, fmt.Errorf("counting documents: %w", err)
	}

	querySQL, queryArgs := q.Build()
	rows, err := c.db.QueryContext(ctx, querySQL, queryArgs...)
	if err != nil {
		return nil, fmt.Errorf("querying documents: %w", err)
	}
	defer rows.Close()

	docs, err := ScanRows(rows)
	if err != nil {
		return nil, err
	}

	for i, doc := range docs {
		docs[i] = c.processRow(doc)
	}

	return &QueryResult{Docs: docs, Total: total}, nil
}

func (c *Collection) FindOne(ctx context.Context, id string) (Row, error) {
	pk := c.schema.PrimaryKeyField()
	if pk == nil {
		return nil, errors.New("collection has no primary key")
	}

	q := NewQuery(c.name).Where(pk.Name, id).Limit(1)
	querySQL, args := q.Build()

	rows, err := c.db.QueryContext(ctx, querySQL, args...)
	if err != nil {
		return nil, fmt.Errorf("querying document: %w", err)
	}
	defer rows.Close()

	docs, err := ScanRows(rows)
	if err != nil {
		return nil, err
	}

	if len(docs) == 0 {
		return nil, ErrNotFound
	}

	return c.processRow(docs[0]), nil
}

func (c *Collection) Create(ctx context.Context, data Row) (Row, error) {
	pk := c.schema.PrimaryKeyField()
	if pk == nil {
		return nil, errors.New("collection has no primary key")
	}

	processedData := c.processInput(data, true)

	if pk.IsAutoGenerated() {
		if _, ok := processedData[pk.Name]; !ok {
			processedData[pk.Name] = uuid.New().String()
		}
	}

	insert := NewInsert(c.name)
	for _, field := range c.schema.OrderedFields() {
		if val, ok := processedData[field.Name]; ok {
			insert.Set(field.Name, val)
		} else if field.IsTimestampNow() {
			insert.Set(field.Name, Now())
		}
	}

	insertSQL, args := insert.Build()
	_, err := c.db.ExecContext(ctx, insertSQL, args...)
	if err != nil {
		if !errors.Is(ClassifyError(err), err) {
			return nil, ClassifyError(err)
		}
		return nil, fmt.Errorf("inserting document: %w", err)
	}

	return c.FindOne(ctx, fmt.Sprint(processedData[pk.Name]))
}

func (c *Collection) Update(ctx context.Context, id string, data Row) (Row, error) {
	pk := c.schema.PrimaryKeyField()
	if pk == nil {
		return nil, errors.New("collection has no primary key")
	}

	existing, err := c.FindOne(ctx, id)
	if err != nil {
		return nil, err
	}
	if existing == nil {
		return nil, ErrNotFound
	}

	processedData := c.processInput(data, false)

	update := NewUpdate(c.name).Where(pk.Name, id)

	for fieldName, value := range processedData {
		if fieldName == pk.Name {
			continue
		}
		field, ok := c.schema.Fields[fieldName]
		if !ok {
			continue
		}
		if field.IsAutoUpdateTimestamp() {
			continue
		}
		update.Set(fieldName, value)
	}

	for _, field := range c.schema.Fields {
		if field.IsAutoUpdateTimestamp() {
			update.Set(field.Name, Now())
		}
	}

	updateSQL, args := update.Build()
	result, err := c.db.ExecContext(ctx, updateSQL, args...)
	if err != nil {
		if !errors.Is(ClassifyError(err), err) {
			return nil, ClassifyError(err)
		}
		return nil, fmt.Errorf("updating document: %w", err)
	}

	if affected, err := result.RowsAffected(); err == nil && affected == 0 {
		return nil, ErrNotFound
	}

	return c.FindOne(ctx, id)
}

func (c *Collection) Delete(ctx context.Context, id string) error {
	pk := c.schema.PrimaryKeyField()
	if pk == nil {
		return errors.New("collection has no primary key")
	}

	deleteSQL, args := NewDelete(c.name).Where(pk.Name, id).Build()
	result, err := c.db.ExecContext(ctx, deleteSQL, args...)
	if err != nil {
		return fmt.Errorf("deleting document: %w", err)
	}

	if affected, err := result.RowsAffected(); err == nil && affected == 0 {
		return ErrNotFound
	}

	return nil
}

func (c *Collection) Count(ctx context.Context, filters []*Filter) (int64, error) {
	q := NewQuery(c.name)
	for _, f := range filters {
		q.Filter(f.Field, f.Op, f.Value)
	}

	countSQL, args := q.BuildCount()
	var count int64
	if err := c.db.QueryRowContext(ctx, countSQL, args...).Scan(&count); err != nil {
		return 0, fmt.Errorf("counting documents: %w", err)
	}

	return count, nil
}

func (c *Collection) Exists(ctx context.Context, id string) (bool, error) {
	pk := c.schema.PrimaryKeyField()
	if pk == nil {
		return false, errors.New("collection has no primary key")
	}

	q := NewQuery(c.name).Select("1").Where(pk.Name, id).Limit(1)
	querySQL, args := q.Build()

	var exists int
	err := c.db.QueryRowContext(ctx, querySQL, args...).Scan(&exists)
	if errors.Is(err, sql.ErrNoRows) {
		return false, nil
	}
	if err != nil {
		return false, err
	}

	return true, nil
}

func (c *Collection) processInput(data Row, isCreate bool) Row {
	result := make(Row)

	for fieldName, value := range data {
		field, ok := c.schema.Fields[fieldName]
		if !ok {
			continue
		}

		if field.Internal && !isCreate {
			continue
		}

		result[fieldName] = c.convertValue(value, field)
	}

	return result
}

func (c *Collection) processRow(row Row) Row {
	for fieldName, value := range row {
		field, ok := c.schema.Fields[fieldName]
		if !ok {
			continue
		}

		if field.Internal {
			delete(row, fieldName)
			continue
		}

		switch field.Type {
		case schema.FieldTypeBool:
			if v, ok := value.(int64); ok {
				row[fieldName] = v != 0
			}
		case schema.FieldTypeJSON:
			if s, ok := value.(string); ok && s != "" {
				var parsed any
				if err := json.Unmarshal([]byte(s), &parsed); err == nil {
					row[fieldName] = parsed
				}
			}
		case schema.FieldTypeTimestamp:
			if s, ok := value.(string); ok && s != "" {
				if t, err := time.Parse(time.RFC3339, s); err == nil {
					row[fieldName] = t
				}
			}
		case schema.FieldTypeUUID, schema.FieldTypeString, schema.FieldTypeText, schema.FieldTypeInt, schema.FieldTypeFloat, schema.FieldTypeBlob:
			// No conversion needed
		}
	}

	return row
}

func (c *Collection) getSearchableFields() []string {
	var fields []string
	for _, f := range c.schema.OrderedFields() {
		if f.Type == schema.FieldTypeString || f.Type == schema.FieldTypeText || f.Type == schema.FieldTypeUUID {
			fields = append(fields, f.Name)
		}
	}
	return fields
}

func (c *Collection) convertValue(value any, field *schema.Field) any {
	if value == nil {
		return nil
	}

	switch field.Type {
	case schema.FieldTypeBool:
		switch v := value.(type) {
		case bool:
			if v {
				return 1
			}
			return 0
		case int, int64, float64:
			return v
		}
	case schema.FieldTypeJSON:
		switch v := value.(type) {
		case string:
			return v
		default:
			if b, err := json.Marshal(v); err == nil {
				return string(b)
			}
		}
	case schema.FieldTypeTimestamp:
		switch v := value.(type) {
		case time.Time:
			return v.UTC().Format(time.RFC3339)
		case string:
			return v
		}
	case schema.FieldTypeUUID, schema.FieldTypeString, schema.FieldTypeText, schema.FieldTypeInt, schema.FieldTypeFloat, schema.FieldTypeBlob:
		// Return as-is
	}

	return value
}
