package database

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/watzon/alyx/internal/schema"
)

type ValidationError struct {
	Field   string `json:"field"`
	Code    string `json:"code"`
	Message string `json:"message"`
}

func (e *ValidationError) Error() string {
	return e.Message
}

type ValidationErrors struct {
	Errors []ValidationError `json:"errors"`
}

func (e *ValidationErrors) Error() string {
	if len(e.Errors) == 0 {
		return "validation failed"
	}
	return e.Errors[0].Message
}

func (e *ValidationErrors) Add(field, code, message string) {
	e.Errors = append(e.Errors, ValidationError{
		Field:   field,
		Code:    code,
		Message: message,
	})
}

func (e *ValidationErrors) HasErrors() bool {
	return len(e.Errors) > 0
}

func ValidateInput(s *schema.Collection, data Row, isCreate bool) *ValidationErrors {
	errs := &ValidationErrors{}

	for _, field := range s.OrderedFields() {
		value, provided := data[field.Name]

		if field.Primary && field.IsAutoGenerated() {
			continue
		}
		if field.IsTimestampNow() || field.IsAutoUpdateTimestamp() {
			continue
		}

		if isCreate && !provided && !field.Nullable && !field.HasDefault() {
			errs.Add(field.Name, "required", fmt.Sprintf("Field '%s' is required", field.Name))
			continue
		}

		if !provided || value == nil {
			continue
		}

		validateFieldValue(field, value, errs)
	}

	return errs
}

func validateFieldValue(field *schema.Field, value any, errs *ValidationErrors) {
	switch field.Type {
	case schema.FieldTypeString, schema.FieldTypeText:
		validateString(field, value, errs)
	case schema.FieldTypeInt:
		validateInt(field, value, errs)
	case schema.FieldTypeFloat:
		validateFloat(field, value, errs)
	case schema.FieldTypeUUID:
		validateUUID(field, value, errs)
	case schema.FieldTypeBool, schema.FieldTypeTimestamp, schema.FieldTypeJSON, schema.FieldTypeBlob:
		// No specific validation
	}

	if field.Validate != nil {
		validateWithRules(field, value, errs)
	}
}

func validateString(field *schema.Field, value any, errs *ValidationErrors) {
	str, ok := toString(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be a string", field.Name))
		return
	}

	if field.MinLength != nil && len(str) < *field.MinLength {
		errs.Add(field.Name, "min_length", fmt.Sprintf("Field '%s' must be at least %d characters", field.Name, *field.MinLength))
	}
	if field.MaxLength != nil && len(str) > *field.MaxLength {
		errs.Add(field.Name, "max_length", fmt.Sprintf("Field '%s' must be at most %d characters", field.Name, *field.MaxLength))
	}
}

func validateInt(field *schema.Field, value any, errs *ValidationErrors) {
	_, ok := toInt(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be an integer", field.Name))
	}
}

func validateFloat(field *schema.Field, value any, errs *ValidationErrors) {
	_, ok := toFloat(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be a number", field.Name))
	}
}

var uuidRegex = regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`)

func validateUUID(field *schema.Field, value any, errs *ValidationErrors) {
	str, ok := toString(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be a string", field.Name))
		return
	}
	if !uuidRegex.MatchString(str) {
		errs.Add(field.Name, "invalid_uuid", fmt.Sprintf("Field '%s' must be a valid UUID", field.Name))
	}
}

func validateWithRules(field *schema.Field, value any, errs *ValidationErrors) {
	v := field.Validate
	validateStringLength(field, value, v, errs)
	validateNumericRange(field, value, v, errs)
	validatePattern(field, value, v, errs)
	validateEnum(field, value, v, errs)

	if v.Format != "" {
		validateFormat(field, value, v.Format, errs)
	}
}

func validateStringLength(field *schema.Field, value any, v *schema.FieldValidation, errs *ValidationErrors) {
	str, ok := toString(value)
	if !ok {
		return
	}

	if v.MinLength != nil && len(str) < *v.MinLength {
		errs.Add(field.Name, "min_length", fmt.Sprintf("Field '%s' must be at least %d characters", field.Name, *v.MinLength))
	}

	if v.MaxLength != nil && len(str) > *v.MaxLength {
		errs.Add(field.Name, "max_length", fmt.Sprintf("Field '%s' must be at most %d characters", field.Name, *v.MaxLength))
	}
}

func validateNumericRange(field *schema.Field, value any, v *schema.FieldValidation, errs *ValidationErrors) {
	num, ok := toFloat(value)
	if !ok {
		return
	}

	if v.Min != nil && num < *v.Min {
		errs.Add(field.Name, "min_value", fmt.Sprintf("Field '%s' must be at least %v", field.Name, *v.Min))
	}

	if v.Max != nil && num > *v.Max {
		errs.Add(field.Name, "max_value", fmt.Sprintf("Field '%s' must be at most %v", field.Name, *v.Max))
	}
}

func validatePattern(field *schema.Field, value any, v *schema.FieldValidation, errs *ValidationErrors) {
	if v.Pattern == "" {
		return
	}

	str, ok := toString(value)
	if !ok {
		return
	}

	re, err := regexp.Compile(v.Pattern)
	if err == nil && !re.MatchString(str) {
		errs.Add(field.Name, "pattern", fmt.Sprintf("Field '%s' does not match required pattern", field.Name))
	}
}

func validateEnum(field *schema.Field, value any, v *schema.FieldValidation, errs *ValidationErrors) {
	if len(v.Enum) == 0 {
		return
	}

	str, ok := toString(value)
	if !ok {
		return
	}

	for _, e := range v.Enum {
		if str == e {
			return
		}
	}

	errs.Add(field.Name, "enum", fmt.Sprintf("Field '%s' must be one of: %s", field.Name, strings.Join(v.Enum, ", ")))
}

var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
var urlRegex = regexp.MustCompile(`^https?://[^\s/$.?#].[^\s]*$`)

func validateFormat(field *schema.Field, value any, format string, errs *ValidationErrors) {
	str, ok := toString(value)
	if !ok {
		return
	}

	switch format {
	case "email":
		if !emailRegex.MatchString(str) {
			errs.Add(field.Name, "format_email", fmt.Sprintf("Field '%s' must be a valid email address", field.Name))
		}
	case "url", "uri":
		if !urlRegex.MatchString(str) {
			errs.Add(field.Name, "format_url", fmt.Sprintf("Field '%s' must be a valid URL", field.Name))
		}
	case "uuid":
		if !uuidRegex.MatchString(str) {
			errs.Add(field.Name, "format_uuid", fmt.Sprintf("Field '%s' must be a valid UUID", field.Name))
		}
	}
}

func toString(v any) (string, bool) {
	switch val := v.(type) {
	case string:
		return val, true
	case []byte:
		return string(val), true
	default:
		return "", false
	}
}

func toInt(v any) (int64, bool) {
	switch val := v.(type) {
	case int:
		return int64(val), true
	case int64:
		return val, true
	case float64:
		return int64(val), true
	case float32:
		return int64(val), true
	default:
		return 0, false
	}
}

func toFloat(v any) (float64, bool) {
	switch val := v.(type) {
	case float64:
		return val, true
	case float32:
		return float64(val), true
	case int:
		return float64(val), true
	case int64:
		return float64(val), true
	default:
		return 0, false
	}
}
