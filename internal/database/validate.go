package database

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/watzon/alyx/internal/schema"
)

type ValidationError struct {
	Field   string `json:"field"`
	Code    string `json:"code"`
	Message string `json:"message"`
}

func (e *ValidationError) Error() string {
	return e.Message
}

type ValidationErrors struct {
	Errors []ValidationError `json:"errors"`
}

func (e *ValidationErrors) Error() string {
	if len(e.Errors) == 0 {
		return "validation failed"
	}
	return e.Errors[0].Message
}

func (e *ValidationErrors) Add(field, code, message string) {
	e.Errors = append(e.Errors, ValidationError{
		Field:   field,
		Code:    code,
		Message: message,
	})
}

func (e *ValidationErrors) HasErrors() bool {
	return len(e.Errors) > 0
}

func ValidateInput(s *schema.Collection, data Row, isCreate bool) *ValidationErrors {
	errs := &ValidationErrors{}

	for _, field := range s.OrderedFields() {
		value, provided := data[field.Name]

		if field.Primary && field.IsAutoGenerated() {
			continue
		}
		if field.IsTimestampNow() || field.IsAutoUpdateTimestamp() {
			continue
		}

		if isCreate && !provided && !field.Nullable && !field.HasDefault() {
			errs.Add(field.Name, "required", fmt.Sprintf("Field '%s' is required", field.Name))
			continue
		}

		if !provided || value == nil {
			continue
		}

		validateFieldValue(field, value, errs)
	}

	return errs
}

func validateFieldValue(field *schema.Field, value any, errs *ValidationErrors) {
	switch field.Type {
	case schema.FieldTypeString, schema.FieldTypeText, schema.FieldTypeRichText:
		validateString(field, value, errs)
	case schema.FieldTypeInt:
		validateInt(field, value, errs)
	case schema.FieldTypeFloat:
		validateFloat(field, value, errs)
	case schema.FieldTypeUUID, schema.FieldTypeRelation:
		validateUUID(field, value, errs)
	case schema.FieldTypeEmail:
		validateEmail(field, value, errs)
	case schema.FieldTypeURL:
		validateURL(field, value, errs)
	case schema.FieldTypeDate:
		validateDate(field, value, errs)
	case schema.FieldTypeSelect:
		validateSelect(field, value, errs)
	case schema.FieldTypeBool, schema.FieldTypeTimestamp, schema.FieldTypeJSON, schema.FieldTypeBlob, schema.FieldTypeFile:
		// No validation needed
	}
}

func validateString(field *schema.Field, value any, errs *ValidationErrors) {
	str, ok := toString(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be a string", field.Name))
		return
	}

	if field.MinLength != nil && len(str) < *field.MinLength {
		errs.Add(field.Name, "min_length", fmt.Sprintf("Field '%s' must be at least %d characters", field.Name, *field.MinLength))
	}
	if field.MaxLength != nil && len(str) > *field.MaxLength {
		errs.Add(field.Name, "max_length", fmt.Sprintf("Field '%s' must be at most %d characters", field.Name, *field.MaxLength))
	}
}

func validateInt(field *schema.Field, value any, errs *ValidationErrors) {
	_, ok := toInt(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be an integer", field.Name))
	}
}

func validateFloat(field *schema.Field, value any, errs *ValidationErrors) {
	_, ok := toFloat(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be a number", field.Name))
	}
}

var uuidRegex = regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`)
var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
var urlRegex = regexp.MustCompile(`^https?://[^\s/$.?#].[^\s]*$`)

func validateUUID(field *schema.Field, value any, errs *ValidationErrors) {
	str, ok := toString(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be a string", field.Name))
		return
	}
	if !uuidRegex.MatchString(str) {
		errs.Add(field.Name, "invalid_uuid", fmt.Sprintf("Field '%s' must be a valid UUID", field.Name))
	}
}

func validateEmail(field *schema.Field, value any, errs *ValidationErrors) {
	str, ok := toString(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be a string", field.Name))
		return
	}
	if !emailRegex.MatchString(str) {
		errs.Add(field.Name, "invalid_email", fmt.Sprintf("Field '%s' must be a valid email address", field.Name))
	}
}

func validateURL(field *schema.Field, value any, errs *ValidationErrors) {
	str, ok := toString(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be a string", field.Name))
		return
	}
	if !urlRegex.MatchString(str) {
		errs.Add(field.Name, "invalid_url", fmt.Sprintf("Field '%s' must be a valid URL", field.Name))
	}
}

var dateRegex = regexp.MustCompile(`^\d{4}-\d{2}-\d{2}$`)

func validateDate(field *schema.Field, value any, errs *ValidationErrors) {
	str, ok := toString(value)
	if !ok {
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be a string", field.Name))
		return
	}
	if !dateRegex.MatchString(str) {
		errs.Add(field.Name, "invalid_date", fmt.Sprintf("Field '%s' must be a valid date (YYYY-MM-DD)", field.Name))
	}
}

func validateSelect(field *schema.Field, value any, errs *ValidationErrors) {
	if field.Select == nil {
		return
	}

	values := field.Select.Values
	maxSelect := field.Select.MaxSelect

	switch v := value.(type) {
	case string:
		if !contains(values, v) {
			errs.Add(field.Name, "invalid_select", fmt.Sprintf("Field '%s' must be one of: %s", field.Name, strings.Join(values, ", ")))
		}
	case []any:
		if maxSelect == 1 {
			errs.Add(field.Name, "invalid_select", fmt.Sprintf("Field '%s' only allows single selection", field.Name))
			return
		}
		if maxSelect > 0 && len(v) > maxSelect {
			errs.Add(field.Name, "max_select", fmt.Sprintf("Field '%s' allows at most %d selections", field.Name, maxSelect))
			return
		}
		for _, item := range v {
			str, ok := item.(string)
			if !ok {
				errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' values must be strings", field.Name))
				return
			}
			if !contains(values, str) {
				errs.Add(field.Name, "invalid_select", fmt.Sprintf("Field '%s' contains invalid value %q; must be one of: %s", field.Name, str, strings.Join(values, ", ")))
			}
		}
	case []string:
		if maxSelect == 1 {
			errs.Add(field.Name, "invalid_select", fmt.Sprintf("Field '%s' only allows single selection", field.Name))
			return
		}
		if maxSelect > 0 && len(v) > maxSelect {
			errs.Add(field.Name, "max_select", fmt.Sprintf("Field '%s' allows at most %d selections", field.Name, maxSelect))
			return
		}
		for _, str := range v {
			if !contains(values, str) {
				errs.Add(field.Name, "invalid_select", fmt.Sprintf("Field '%s' contains invalid value %q; must be one of: %s", field.Name, str, strings.Join(values, ", ")))
			}
		}
	default:
		errs.Add(field.Name, "invalid_type", fmt.Sprintf("Field '%s' must be a string or array of strings", field.Name))
	}
}

func contains(slice []string, item string) bool {
	for _, v := range slice {
		if v == item {
			return true
		}
	}
	return false
}

func toString(v any) (string, bool) {
	switch val := v.(type) {
	case string:
		return val, true
	case []byte:
		return string(val), true
	default:
		return "", false
	}
}

func toInt(v any) (int64, bool) {
	switch val := v.(type) {
	case int:
		return int64(val), true
	case int64:
		return val, true
	case float64:
		return int64(val), true
	case float32:
		return int64(val), true
	default:
		return 0, false
	}
}

func toFloat(v any) (float64, bool) {
	switch val := v.(type) {
	case float64:
		return val, true
	case float32:
		return float64(val), true
	case int:
		return float64(val), true
	case int64:
		return float64(val), true
	default:
		return 0, false
	}
}
